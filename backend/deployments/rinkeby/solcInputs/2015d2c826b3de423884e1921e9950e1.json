{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/ISyntheticPunksAssets.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ninterface ISyntheticPunksAssets {\n  function spritesheetImageData() external view returns (string memory);\n  function spritesheetRanges() external view returns (uint256[4][9] memory);\n  function attributesContentURI() external view returns (string memory);\n}"
    },
    "contracts/SyntheticPunksAssets.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"./interfaces/ISyntheticPunksAssets.sol\";\n\ncontract SyntheticPunksAssets is ISyntheticPunksAssets {\n\n  uint256[4][9] private __spritesheetRanges;\n  string override public attributesContentURI;\n\n  constructor(uint256[4][9] memory _spritesheetRanges, string memory _attributesContentURI) {\n    __spritesheetRanges = _spritesheetRanges;\n    attributesContentURI = _attributesContentURI;\n  }\n\n  function spritesheetRanges() external override view returns (uint256[4][9] memory) {\n    return __spritesheetRanges;\n  }\n\n  string override public constant spritesheetImageData = \"data:image/png;charset:utf-8;base64,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\";\n  \n}"
    },
    "contracts/SyntheticPunks.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport \"./interfaces/ISyntheticPunksAssets.sol\";\n\nabstract contract ReverseRecords {\n  function getNames(address[] calldata addresses) external view virtual returns (string[] memory r);\n}\n\ncontract SyntheticPunks is ERC721 {\n\n  ISyntheticPunksAssets public assets;\n  uint256 public immutable claimPrice = 0.02 ether;\n  address public immutable withdrawAddress;\n  address immutable ensReverseAddress;\n  string public constant claimMessage = \"Message to claim Synthetic Punk\";\n\n  mapping(address => bool) public claimed;\n\n  enum Gender { Male, Female }\n\n  constructor(\n    string memory _name, \n    string memory _symbol, \n    address _assetsAddress,\n    address _withdrawAddress,\n    address _ensReverseAddress\n  ) ERC721(_name, _symbol) {\n    assets = ISyntheticPunksAssets(_assetsAddress);\n    withdrawAddress = _withdrawAddress;\n    ensReverseAddress = _ensReverseAddress;\n  }\n\n  function claim() public payable {\n    require(msg.value >= claimPrice, \"Insufficient payment\");\n    _safeMint(msg.sender, getTokenID(msg.sender));\n    claimed[msg.sender] = true;\n    uint256 refund = msg.value - claimPrice;\n    if (refund > 0) {\n      payable(msg.sender).transfer(refund);\n    }\n  }\n\n  function claimOther(address _signer, bytes memory _signature) public payable {\n    require(msg.value >= claimPrice, \"Insufficient payment\");\n    require(verify(_signer, claimMessage, _signature), \"Invalid signature\");\n\n    _safeMint(msg.sender, getTokenID(_signer));\n    claimed[_signer] = true;\n    uint256 refund = msg.value - claimPrice;\n    if (refund > 0) {\n      payable(_signer).transfer(refund);\n    }\n  }\n\n  \n\n  function withdraw() public {\n    payable(withdrawAddress).transfer(address(this).balance);\n  }\n\n  function _tokenURI(address _address) public view returns (string memory) {\n    return tokenURI(getTokenID(_address));\n  }\n\n  function getTokenID(address _address) public pure returns (uint256) {\n    return uint256(uint160(_address));\n  }\n\n  function getAddress(uint256 id) public pure returns (address) {\n    return address(uint160(id));\n  }\n\n  function tokenURI(uint256 id) public view override returns (string memory) {\n    uint256[] memory layers = getAttributes(id);\n    string memory punkSVG = generatePunkSVG(layers);\n\n    address userAddress = getAddress(id);\n    string memory ensName = reverseName(userAddress);  \n    string memory addressOrENS = bytes(ensName).length == 0 ? toString(userAddress) : ensName;\n    \n    string memory json = base64(bytes(abi.encodePacked('{\"name\": \"', 'Synthetic CryptoPunk for ', addressOrENS, '\", \"description\": \"This is a unique Punk claimed by ', addressOrENS,'.\", \"image\": \"data:image/svg+xml;base64,', base64(bytes(punkSVG)), '\"}')));\n\n    return string(abi.encodePacked('data:application/json;base64,', json));\n  }\n\n  // Entropy 0\n  function getGender(uint256 id) public view returns (Gender) {\n    return randomUint(id, 0) % 2 == 0 ? Gender.Male : Gender.Female;\n  }\n\n  // Entropy 1,2-9\n  function getAttributeCategories(uint256 id) public view returns (uint256[] memory) {\n    uint256[4][9] memory spritesheetRanges = assets.spritesheetRanges();\n    uint256 checks = 2 + randomUint(id, 1) % (spritesheetRanges.length - 3); // Number of bytes to check\n    uint256[] memory attributes = new uint256[](checks); // TODO: Check at least 1 attribute\n    uint256 length = 0;\n    for (uint256 i; i < checks; i++) {\n      uint256 newAttribute = randomUint(id, 2+i) % (spritesheetRanges.length - 2) + 1; // Skip base category\n      \n      bool added = contains(attributes, newAttribute);\n\n      if (added) {\n        continue;\n      }\n\n      if (getGender(id) == Gender.Female) {\n        if (!(spritesheetRanges[newAttribute][3] - spritesheetRanges[newAttribute][1] == 0)) {\n          attributes[length] = newAttribute;\n          length++;\n        }\n      } else {\n        if (!(spritesheetRanges[newAttribute][2] - spritesheetRanges[newAttribute][0] == 0)) {\n          attributes[length] = newAttribute;\n          length++;\n        }\n      }\n    }\n\n    uint256[] memory attributesResized = new uint256[](length+1);\n    attributesResized[0] = 0;\n    for (uint256 i; i < length; i++) {\n      attributesResized[i+1] = attributes[i];\n    }\n\n    return attributesResized;\n  }\n\n  // Entropy 10\n  function getAttribute(uint256 id, uint256 _attributeId) public view returns (uint256) {\n    uint256[4] memory ranges = assets.spritesheetRanges()[_attributeId];\n    Gender gender = getGender(id);\n    if (gender == Gender.Female) {\n      return ranges[1] + randomUint(id, 10+_attributeId) % (ranges[3] - ranges[1]);\n    } else {\n      return ranges[0] + randomUint(id, 10+_attributeId) % (ranges[2] - ranges[0]);\n    }\n  }\n\n  function _getAttributes(address _address) public view returns (uint256[] memory) {\n    return getAttributes(getTokenID(_address));\n  }\n\n  function getAttributes(uint256 id) public view returns (uint256[] memory) {\n    uint256[] memory attributeCategories = getAttributeCategories(id);\n    uint256[] memory layers = new uint256[](attributeCategories.length);\n    for (uint256 i = 0; i < attributeCategories.length; i++) {\n      layers[i] = getAttribute(id, attributeCategories[i]);\n    }\n    return layers;\n  }\n\n  function generatePunkSVG(uint256[] memory layers) public view returns (string memory) {\n    string memory start1 = '<svg viewBox=\"0 0 24 24\" width=\"1000\" xmlns=\"http://www.w3.org/2000/svg\" ><defs><style>#spritesheet { image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; image-rendering: pixelated; } #punk { filter: drop-shadow(0px 0px 50px rgb(0, 255, 166, 0.7)); } svg { background : #6A9480; }</style><svg width=\"24\" height=\"24\" viewBox=\"48 0 24 24\"><image id=\"spritesheet\" preserveAspectRatio=\"xMinYMin slice\" href=\"';\n    string memory start3 = '\"></image></svg></defs><svg id=\"punk\">';\n    string memory end = '</svg></svg>';\n    string memory layersSVG = '';\n\n    // Render in order\n    for (uint256 i = 0; i < assets.spritesheetRanges().length; i++) {\n      for (uint256 j = 0; j < layers.length; j++) {\n        if (assets.spritesheetRanges()[i][0] <= layers[j] && layers[j] < assets.spritesheetRanges()[i][3]) { // if layer is in range\n          // console.log(layers[j]);\n          uint256 id = layers[j];\n          uint256 x = (id % 24) * 24;\n          uint256 y = (id / 24) * 24;\n          layersSVG = string(abi.encodePacked(layersSVG, '<svg width=\"24\" height=\"24\" viewBox=\"', toString(x), ' ', toString(y), ' 24 24\"><use href=\"#spritesheet\"></use></svg>'));\n          break;\n        }\n      }\n    }\n\n    return string(abi.encodePacked(start1, assets.spritesheetImageData(), start3, layersSVG, end)) ;\n  }\n  \n  function reverseName(address _address) internal view returns (string memory name) {\n    if (address(0) == ensReverseAddress) {\n      return name;\n    }\n    ReverseRecords ens = ReverseRecords(ensReverseAddress);\n    address[] memory t = new address[](1);\n    t[0] = _address;\n    name = ens.getNames(t)[0];\n  }\n\n  function contains(uint256[] memory arr, uint256 element) internal pure returns (bool) {\n    for (uint256 i = 0; i < arr.length; i++) {\n      if (arr[i] == element) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function randomUint(uint256 seed, uint256 offset) public view returns (uint256) {\n    require(offset < 32, \"Offset out of bounds\");\n    bytes32 entropy = keccak256(abi.encodePacked(address(this), seed)); // TODO: Consider not including address in entropy\n    bytes32 mask = bytes32(0xff << (offset * 8));\n    uint256 out = uint256((entropy & mask) >> (offset * 8));\n    return out;\n  }\n\n  function toString(address account) public pure returns(string memory) {\n    return toString(abi.encodePacked(account));\n  }\n\n  function toString(bytes32 value) public pure returns(string memory) {\n    return toString(abi.encodePacked(value));\n  }\n\n  function toString(bytes memory data) public pure returns(string memory) {\n    bytes memory alphabet = \"0123456789abcdef\";\n\n    bytes memory str = new bytes(2 + data.length * 2);\n    str[0] = \"0\";\n    str[1] = \"x\";\n    for (uint i = 0; i < data.length; i++) {\n        str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\n        str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\n    }\n    return string(str);\n  }\n\n  function toString(uint256 n) \n      internal \n      pure \n      returns (string memory nstr) \n  {\n    uint256 MAX_UINT256_STRING_LENGTH = 78;\n    uint8 ASCII_DIGIT_OFFSET = 48;\n    if (n == 0) {\n        return \"0\";\n    }\n    // Overallocate memory\n    nstr = new string(MAX_UINT256_STRING_LENGTH);\n    uint256 k = MAX_UINT256_STRING_LENGTH;\n    // Populate string from right to left (lsb to msb).\n    while (n != 0) {\n      assembly {\n        let char := add(\n          ASCII_DIGIT_OFFSET,\n          mod(n, 10)\n        )\n        mstore(add(nstr, k), char)\n        k := sub(k, 1)\n        n := div(n, 10)\n      }\n    }\n    assembly {\n      // Shift pointer over to actual start of string.\n      nstr := add(nstr, k)\n      // Store actual string length.\n      mstore(nstr, sub(MAX_UINT256_STRING_LENGTH, k))\n    }\n    return nstr;\n  }\n\n  /// @notice Encodes some bytes to the base64 representation\n  function base64(bytes memory data) internal pure returns (string memory) {\n    bytes memory TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    uint256 len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint256 encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n          mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n          mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n\n  // ECDSA\n\n  function getMessageHash(\n    string memory _message\n  ) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_message));\n  }\n\n  function getEthSignedMessageHash(bytes32 _messageHash)\n    public\n    pure \n    returns (bytes32)\n  {\n    return\n      keccak256(\n        abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash)\n      );\n  }\n\n  function verify(\n    address _signer,\n    string memory _message,\n    bytes memory signature\n  ) public pure returns (bool) {\n    bytes32 messageHash = getMessageHash(_message);\n    bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\n\n    return recoverSigner(ethSignedMessageHash, signature) == _signer;\n  }\n\n  function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\n    public\n    pure\n    returns (address)\n  {\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n    return ecrecover(_ethSignedMessageHash, v, r, s);\n  }\n\n  function splitSignature(bytes memory sig)\n    public\n    pure\n    returns (\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    )\n  {\n    require(sig.length == 65, \"invalid signature length\");\n\n    assembly {\n      // first 32 bytes, after the length prefix\n      r := mload(add(sig, 32))\n      // second 32 bytes\n      s := mload(add(sig, 64))\n      // final byte (first byte of the next 32 bytes)\n      v := byte(0, mload(add(sig, 96)))\n    }\n  }\n}"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}