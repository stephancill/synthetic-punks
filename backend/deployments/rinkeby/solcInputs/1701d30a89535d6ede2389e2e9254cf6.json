{
  "language": "Solidity",
  "sources": {
    "contracts/SyntheticPunks.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ncontract SyntheticPunks is ERC721 {\n\n  // TODO: Check if constants are cheaper\n  // TODO: Attributes csv IPFS content hash\n  string public spritesheetImageData;\n  uint256[4][9] public spritesheetRanges;\n  uint256 public claimPrice = 0.02 ether;\n  address public withdrawAddress;\n\n  mapping(address => bool) public claimed;\n\n  enum Gender { Male, Female }\n\n  constructor(\n    string memory _name, \n    string memory _symbol, \n    string memory _spritesheetImageData, \n    uint256[4][9] memory _spritesheetRanges,\n    address _withdrawAddress\n  ) ERC721(_name, _symbol) {\n    spritesheetImageData = _spritesheetImageData;\n    spritesheetRanges = _spritesheetRanges;\n    withdrawAddress = _withdrawAddress;\n  }\n\n  function claim() public payable {\n    require(msg.value >= claimPrice, \"Insufficient payment\");\n    _safeMint(msg.sender, uint256(uint160(msg.sender)));\n    claimed[msg.sender] = true;\n    uint256 refund = msg.value - claimPrice;\n    if (refund > 0) {\n      payable(msg.sender).transfer(refund);\n    }\n  }\n\n  function withdraw() public {\n    payable(withdrawAddress).transfer(address(this).balance);\n  }\n\n  function _tokenURI(address _address) public view returns (string memory) {\n    return tokenURI(uint256(uint160(_address)));\n  }\n\n  function tokenID(address _address) public pure returns (uint256) {\n    return uint256(uint160(_address));\n  }\n\n  function tokenURI(uint256 id) public view override returns (string memory) {\n    uint256[] memory attributeCategories = getAttributeCategories(id);\n    uint256[] memory layers = new uint256[](attributeCategories.length);\n    for (uint256 i = 0; i < attributeCategories.length; i++) {\n      layers[i] = getAttribute(id, attributeCategories[i]);\n      // console.log(layers[i]);\n    }\n\n    string memory punkSVG = generatePunkSVG(layers);\n\n    string memory json = base64(bytes(abi.encodePacked('{\"name\": \"Synthetic CryptoPunk #', toString(id), '\", \"description\": \"This is a unique Punk associated with your wallet.\", \"image\": \"data:image/svg+xml;base64,', base64(bytes(punkSVG)), '\"}')));\n\n    return string(abi.encodePacked('data:application/json;base64,', json));\n  }\n\n  // Entropy 0\n  function getGender(uint256 id) public view returns (Gender) {\n    return randomUint(id, 0) % 2 == 0 ? Gender.Male : Gender.Female;\n  }\n\n  // Entropy 1,2-9\n  function getAttributeCategories(uint256 id) public view returns (uint256[] memory) {\n    uint256 checks = randomUint(id, 1) % (spritesheetRanges.length - 1); // Number of bytes to check\n    uint256[] memory attributes = new uint256[](checks);\n    uint256 length = 0;\n    for (uint256 i; i < checks; i++) {\n      uint256 newAttribute = randomUint(id, 2+i) % (spritesheetRanges.length - 2) + 1; // Skip base category\n      \n      bool added = contains(attributes, newAttribute);\n\n      if (added) {\n        continue;\n      }\n\n      if (getGender(id) == Gender.Female) {\n        if (!(spritesheetRanges[newAttribute][3] - spritesheetRanges[newAttribute][1] == 0)) {\n          attributes[length] = newAttribute;\n          length++;\n        }\n      } else {\n        if (!(spritesheetRanges[newAttribute][2] - spritesheetRanges[newAttribute][0] == 0)) {\n          attributes[length] = newAttribute;\n          length++;\n        }\n      }\n    }\n    uint256[] memory attributesResized = new uint256[](length+1);\n    attributesResized[0] = 0;\n    for (uint256 i; i < length; i++) {\n      attributesResized[i+1] = attributes[i];\n    }\n\n    return attributesResized;\n  }\n\n  function contains(uint256[] memory arr, uint256 element) internal pure returns (bool) {\n    for (uint256 i = 0; i < arr.length; i++) {\n      if (arr[i] == element) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Entropy 10\n  function getAttribute(uint256 id, uint256 _attributeId) public view returns (uint256) {\n    uint256[4] memory ranges = spritesheetRanges[_attributeId];\n    Gender gender = getGender(id);\n    if (gender == Gender.Female) {\n      return ranges[1] + randomUint(id, 10+_attributeId) % (ranges[3] - ranges[1]);\n    } else {\n      return ranges[0] + randomUint(id, 10+_attributeId) % (ranges[2] - ranges[0]);\n    }\n  }\n\n  function generatePunkSVG(uint256[] memory layers) public view returns (string memory) {\n    string memory start1 = '<svg viewBox=\"0 0 24 24\" width=\"1000\" xmlns=\"http://www.w3.org/2000/svg\" ><defs><style>#spritesheet { image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; image-rendering: pixelated; }</style><svg width=\"24\" height=\"24\" viewBox=\"48 0 24 24\"><image id=\"spritesheet\" preserveAspectRatio=\"xMinYMin slice\" href=\"';\n    string memory start3 = '\"></image></svg></defs>';\n    string memory end = '</svg>';\n    string memory layersSVG = '';\n\n    // Render in order\n    for (uint256 i = 0; i < spritesheetRanges.length; i++) {\n      for (uint256 j = 0; j < layers.length; j++) {\n        if (spritesheetRanges[i][0] <= layers[j] && layers[j] < spritesheetRanges[i][3]) { // if layer is in range\n          uint256 id = layers[j];\n          uint256 x = (id % 25) * 24;\n          uint256 y = (id / 25) * 24;\n          layersSVG = string(abi.encodePacked(layersSVG, '<svg width=\"24\" height=\"24\" viewBox=\"', toString(x), ' ', toString(y), ' 24 24\"><use href=\"#spritesheet\"></use></svg>'));\n          break;\n        }\n      }\n    }\n\n    return string(abi.encodePacked(start1, spritesheetImageData, start3, layersSVG, end)) ;\n  }\n\n  function randomUint(uint256 seed, uint256 offset) public view returns (uint256) {\n    require(offset < 32, \"Offset out of bounds\");\n    bytes32 entropy = keccak256(abi.encodePacked(address(this), seed)); // TODO: Consider not including address in entropy\n    bytes32 mask = bytes32(0xff << (offset * 8));\n    uint256 out = uint256((entropy & mask) >> (offset * 8));\n    return out;\n  }\n\n  /// @dev Converts a `uint256` value to a string.\n  /// @param n The integer to convert.\n  /// @return nstr `n` as a decimal string.\n  /// Source: https://github.com/mzhu25/sol2string\n  function toString(uint256 n) \n    internal \n    pure \n    returns (string memory nstr) \n  {\n    uint256 MAX_UINT256_STRING_LENGTH = 78;\n    uint8 ASCII_DIGIT_OFFSET = 48;\n    if (n == 0) {\n      return \"0\";\n    }\n    // Overallocate memory\n    nstr = new string(MAX_UINT256_STRING_LENGTH);\n    uint256 k = MAX_UINT256_STRING_LENGTH;\n    // Populate string from right to left (lsb to msb).\n    while (n != 0) {\n      assembly {\n        let char := add(\n          ASCII_DIGIT_OFFSET,\n          mod(n, 10)\n        )\n        mstore(add(nstr, k), char)\n        k := sub(k, 1)\n        n := div(n, 10)\n      }\n    }\n    assembly {\n        // Shift pointer over to actual start of string.\n        nstr := add(nstr, k)\n        // Store actual string length.\n        mstore(nstr, sub(MAX_UINT256_STRING_LENGTH, k))\n    }\n    return nstr;\n  }\n\n  /// @notice Encodes some bytes to the base64 representation\n  function base64(bytes memory data) internal pure returns (string memory) {\n    bytes memory TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    uint256 len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint256 encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n          mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n          mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n}"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}